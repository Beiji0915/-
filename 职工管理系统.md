# 1.管理系统需求

职工管理系统可以用来管理公司内所有员工的信息



公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责

普通员工职责：完成经理交给的任务

经理职责：完成老板交给的任务，并下发任务给员工

老板职责：管理公司所有事务



管理系统中需要实现的功能如下：

- 退出管理程序：退出当前管理系统
- 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号
- 显示职工信息：显示公司内部所有职工的信息
- 删除离职员工：按照编号删除指定的职工
- 修改职工信息：按照编号修改职工个人信息
- 查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息
- 按照编号排序：按照职工编号，进行排序，排序规则由用户指定
- 清空所有文档：清空文件中记录的所有职工信息（清空前需要再次确认，防止误删）

# ２.创建项目

打开Visual Studio 2022，选择创建新项目，选择语言为C++，选择控制台应用，点击下一步，输入项目名称，更改项目位置，点击创建

![image-20251103183906746](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103183906746.png)

![image-20251103184011876](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103184011876.png)

![image-20251103184148405](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103184148405.png)

# 3.创建管理类

管理类负责的内容如下：

- 与用户的沟通界面
- 对职工增删改查的操作
- 与文件的读写交互

## 3.1 创建文件

在头文件和源文件的文件夹下分别创建workerManager.h和workerManager.cpp文件

![image-20251103184447648](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103184447648.png)

## 3.2 头文件实现

在workerManager.h中设计管理类

```c++
#pragma once	//防止头文件重复包含
#include <iostream>//包含输入输出流头文件

using namespace std;//使用标准命名空间

//创建管理类
class workerManager
{
public:
	workerManager();//构造函数的声明

	~workerManager();//析构函数的声明

};
```

在workerManger.cpp中实现函数

目前是空实现

```c++
#include "workerManager.h"//与头文件关联

workerManager::workerManager()
{

}

workerManager::~workerManager()
{


}	
```

# 4.菜单功能

功能描述：与用户沟通的界面

## 4.1添加成员函数

在管理类中添加成员函数void show_Menu();

首先在头文件中进行声明：

![image-20251103185350862](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103185350862.png)

在源文件中实现函数：

![image-20251103185826281](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103185826281.png)

在主文件中包含头文件，并创建对象来调用显示菜单函数

![image-20251103221910324](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103221910324.png)

# 5.退出功能

在main函数中提供分支选择，提供每个功能的接口。

利用switch case 语句来判断用户输入。

```c++
int main()
{
	workerManager wm;

	int choice = 0;
	while (1)
	{
		wm.show_Menu();//放入循环里，让每一次都显示菜单
		cout << "请输入您想使用的功能：";
		cin >> choice;//等待用户输入
			switch (choice)
			{
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			case 7:
				break;
			}
	}
	system("pause");
	return 0;
}
```

当用户输入0到7之内时程序会正常执行，如果用户输入的数不是0到7之间，不会执行任何操作，而是直接再次进入循环，有两种解决方法，第一种在switch语句最后加入default，让default语句来执行return 0 ，这样就可以防止循环。第二种方法是在执行switch之前加入if判断语句，如果用户输入正确的操作数就进入switch语句，如果不正确则退出。

还要一个小问题，如果用户输入的是字符或字符串的话，因为我们使用了int类型来接收用户的输入，所以用户输入的值并不会赋值给choice，choice还是保持之前我们初始化的值，也就是0。不会造成程序崩溃。

第一种方式：

```c++
default : 
	cout<<"输入不合法"<<endl;
	return 0;
	break;//这里的break没有作用，因为上面已经return掉了，但是还是加上，养成习惯
```



第二种方式：

```c++
if (choice >= 0 && choice <= 7)
```



这样就不会因为用户的非法输入造成程序的崩溃或死循环。

然后做退出的功能，还是有两种方法，第一种是在case 0中直接return 0。第二种是再次在管理类中添加退出系统的函数，这里我们使用第二种。

首先在.h头文件中声明退出程序的函数

```c++
//退出程序
void exitsystem();
```

然后在.cpp源文件中实现函数

```c++
//退出程序
void workerManager::exitsystem()
{
	cout << "系统即将退出，感谢您的使用，期待与您的下次见面！" << endl;
	system("pause");//请按任意键继续
	exit(0);//退出程序函数
}
```

最后在case 0分支中调用exitsystem函数即可。

![image-20251103232624071](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251103232624071.png)

# 6.创建职工类

## 6.1 创建职工抽象类

职工的分类为：普通职工、经理、老板

将三种职工抽象到一个类中，利用多态管理不同的职工种类

职工属性为：职工编号、职工姓名、职工所在部门编号

职工行为为：岗位职责信息描述、获取岗位名称



我们依旧选择封装类

在头文件新建worker.h

```c++
#pragma once
#include <iostream>
#include <string>

using namespace std;

//创建职工类
class worker
{
public:
	
	//显示个人信息
	virtual void showInfo() = 0;
	//获取岗位名称
	virtual string getDeptName() = 0;

	int m_Id;//职工编号
	string m_Name;//职工姓名
	int m_DeptId;//职工所在部门编号

};
```

因为我们使用了纯虚函数，所以worker无法实例化对象，所以函数的实现没有必要写

## 6.2 创建普通职工类

接下来创建普通职工类来继承抽象职工类

添加头文件employee.h

```c++
#pragma once
#include <iostream>

#include "worker.h"
using namespace std;

class employee : public worker
{
public:
    //构造函数  用来初始化信息
	employee(int id,string name,int deptid);
	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();

};
```

继承worker类并在子函数中重写父类中的纯虚函数，然后创建源文件employee.cpp，在源文件中实现函数

```c++
#include "employee.h"

//构造函数
employee::employee(int id, string name, int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}
//显示个人信息
void employee::showInfo()
{
	cout << "职工编号：  " << this->m_Id
		<< "\t职工姓名：  " << this->m_Name
		<< "\t岗位：  " << this->getDeptName()
		<< "\t岗位职责：完成经理交给的任务" << endl;
	
}
//获取岗位名称
string employee::getDeptName()
{
	return string("普通员工");
}
```

## 6.3 创建经理类

经理类和普通职工类的做法一样，继承职工抽象类并重写纯虚函数

创建头文件manager.h

```c++
#pragma once
#include <iostream>


#include "worker.h"
using namespace std;

class manager :public worker
{
public:
	manager(int id, string name, int deptid);

	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();
};
```

创建经理类的源文件

```c++
#include "manager.h"

manager::manager(int id,string name,int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}

//显示个人信息
void manager::showInfo()
{
	cout << "职工编号：  " << this->m_Id
		<< "\t职工姓名：  " << this->m_Name
		<< "\t岗位：  " << this->getDeptName()
		<< "\t岗位职责：完成老板交给的任务，并下发任务给员工" << endl;
}
//获取岗位名称
string  manager::getDeptName()
{
	return string("经理");
}

```

## 6.4 创建老板类

boss.h

```c++
#pragma once
#include <iostream>


#include "worker.h"
using namespace std;

class boss :public worker
{
public:
	boss(int id, string name, int deptid);

	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();
};
```

boss.cpp

```c++
#include "boss.h"

boss::boss(int id, string name, int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}

//显示个人信息
void boss::showInfo()
{
	cout << "职工编号：  " << this->m_Id
		<< "\t职工姓名：  " << this->m_Name
		<< "\t岗位：  " << this->getDeptName()
		<< "\t岗位职责：管理公司所有事务" << endl;
}
//获取岗位名称
string  boss::getDeptName()
{
	return string("老板");
}

```

## 6.5 测试多态

目前整个程序已经完成了第一部分，为了防止出现问题，一般情况下都要写一部分测试一部分，现在先测试一下三个职工能不能使用

先注释掉主函数中的其他代码，添加测试代码：

```c++
	worker* w1 = new employee(1,"张三",1);
	w1->getDeptName();
	w1->showInfo();
	delete w1;
	w1 = NULL;
	w1 = new manager(2, "李四", 2);
	w1->getDeptName();
	w1->showInfo();
	delete w1;
	w1 = NULL;
	w1 = new boss(3, "王五", 3);
	w1->getDeptName();
	w1->showInfo();
	delete w1;
	w1 = NULL;
```

![image-20251104170610302](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251104170610302.png)

可以看到没有报错，完美

# 7.添加职工

功能描述：支持批量添加职工，并存储到文件中

## 7.1 功能分析

分析：

用户在批量创建时，可能会创建不同种类的职工

如果想将所有的不同种类的职工都放在同一个数组中，可以将所有的员工的指针维护到一个数组中

如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用worker**的指针维护

## 7.2 功能实现

首先我们在职工管理类头文件中添加函数：

```c++
#include "worker.h"

	//记录职工人数
	int m_EmpNum;

	//职工数组指针
	worker** m_EmpArray;

	//添加职工函数
	void AddEmp();
```

在源文件中初始化成员属性

```c++
workerManager::workerManager()
{
	//初始化属性
	this->m_EmpNum = 0;

	this->m_EmpArray = NULL;
}
```

实现函数：

```c++
//添加职工
void workerManager::AddEmp()
{
	cout << "请输入您想添加的职工数量：";

	int addnum = 0;//保存用户的输入数量
	cin >> addnum;
	if (addnum > 0)
	{
		//添加
		//计算添加新空间的大小
		int newsize = this->m_EmpNum + addnum;//新空间大小等于原来记录的人数 + 新增人数

		//开辟新空间
		worker ** newspace = new worker* [newsize];

		//如果原来有记录，应该先将原来的空间下的数据拷贝到新空间下
		if (this->m_EmpNum != 0)
		{
			for (int i = 0; i < this->m_EmpNum; i++)
			{
				newspace[i] = this->m_EmpArray[i];
			}
		}
			//批量添加数据
		for (int i = 0; i < addnum; i++)
		{
			int id;//编号
			string name;//姓名
			int dept;//部门编号

			cout << "请输入第" << i + 1 << "位职工的编号：";
			cin >> id;
			cout << endl;
			cout << "请输入第" << i + 1 << "位职工的姓名：";
			cin >> name;
			cout << endl;
			cout << "请输入该职工的部门编号(1:普通职工  2:经理  3:老板)：";
			cin >> dept;
			cout << endl;
				
			worker* worker = NULL;
			switch (dept)
			{
			case 1:
				worker = new employee(id, name, 1);
				break;
			case 2:
				worker = new manager(id, name, 2);
				break;
			case 3:
				worker = new boss(id, name, 3);
				break;
			default:
				break;
			}
				//将创建的职工指针保存到数组中
				newspace[this->m_EmpNum + i] = worker;
			
		}
		//释放原有空间
		delete[] this->m_EmpArray;

		//更改新空间指向
		this->m_EmpArray = newspace;

		//更新职工人数
		this->m_EmpNum = newsize;

		cout << "添加成功，成功添加" << addnum << "位职工" << endl;

		//成功添加后应该做一个保存到文件的操作

	}
	else
	{
		cout << "输入数据有误！" << endl;

	}
	system("pause");
	system("cls");

}
```

# 8.文件交互 写文件

功能描述：对文件进行读写

​	在上一个添加功能中，我们只是将所有内容存储在内存中，在程序关闭后就会被销毁

​	因此在文件管理类中需要一个与文件进行交互的功能，对文件进行读写操作

## 8.1 设置文件路径

首先把文件路径在管理类中设置位宏常量，并包含头文件

```c++
#include <fstream> // 包含文件交互头文件
#define filename "C:/Users/dell/AppData/Roaming/Employee Management/empFile.txt"
```

## 8.2 成员函数声明

在管理类中声明保存文件的函数

```c++
void save();
```

## 8.3 保存文件功能的实现

```c++
//保存文件
void workerManager::save()
{
	fstream ofs;
	ofs.open(filename, ios::out||ios::binary);
	for (int i = 0; i < this->m_EmpNum; i++)
	{
		ofs << this->m_EmpArray[i]->m_Id << "\t"
			<< this->m_EmpArray[i]->m_Name << "\t"
			<< this->m_EmpArray[i]->m_DeptId << endl;
	}


	ofs.close();
}
```

# 9. 文件交互  读文件

功能描述：将文件中的内容读取到程序中

首先要判断文件存不存在，在管理类头文件中添加成员，用来判断文件是否存在

```c++
	//标志文件是否为空
	bool m_fileisempty;
```

然后在源文件中重写构造函数，当文件为空的时候，职工人数和职工数组都应该为空

```c++
workerManager::workerManager()
{

	//读文件
	fstream ifs;
	ifs.open(filename, ios::in | ios::binary);

	//文件不存在情况
	if (!ifs.is_open())
	{
		//cout << "文件不存在" << endl;//测试输出
		this->m_EmpNum = 0;
		this->m_fileisempty = true;
		this->m_EmpArray = NULL;
		ifs.close();
		return;
	}
}
```

如果文件存在但是数据为空的话

```c++
	//文件存在但是数据为空
	char ch;
	ifs >> ch;
	if (ifs.eof())
	{
		cout << "文件为空！" << endl;
		//初始化记录人数
		this->m_EmpNum = 0;
		//初始化数组指针
		this->m_EmpArray = NULL;
		//初始化文件是否为空
		this->m_fileisempty = true;

		ifs.close();
		return;
	}
```

如果文件存在且不为空

首先获取文件中的职工人数

在头文件中添加成员函数：

```c++
//统计人数
int get_EmpNum;
```

在源文件中实现：

```c++
//获取文件中人数
int workerManager::get_EmpNum()
{
	fstream ifs;
	ifs.open(filename, ios::in | ios::binary);

	int id;
	string name;
	int did;

	int num = 0;
	while (ifs >> id && ifs >> name && ifs >> did)
	{
		num++;
	}

	ifs.close();

	return num;
}
```

当文件存在并且其中有数据时，就会返回人数num，因此在构造函数中再追加代码：

```c++
	int num = this->get_EmpNum();
	//cout << "职工人数为：" << num << endl;  //测试代码
	this->m_EmpNum = num;
```

上面我们获取到了文件中的人数，接下来我们通过读取文件中的数据来初始化数组

在头文件中追加初始化函数：

```c++
	//初始化职工
	void init_Emp();
```

在源文件中实现初始化函数：

```c++
//初始化职工
void workerManager::init_Emp()
{
	ifstream ifs;
	ifs.open(filename, ios::in | ios::binary);
	
	int id;
	string name;
	int did;

	int temp = 0;
	while (ifs >> id && ifs >> name && ifs >> did)
	{
		worker* worker = NULL;

		//根据不同的部门id来创建不同的对象
		if (did == 1)
		{
			worker = new employee(id, name, 1);
		}
		else if (did == 2)
		{
			worker = new manager(id, name, 2);
		}
		else
		{
			worker = new boss(id, name, 3);
		} 
		this->m_EmpArray[temp] = worker;
		temp++;
	}



	ifs.close();
}

```

然后在构造函数中追加：

```c++
//文件存在并且数据不为空
int num = this->get_EmpNum();
//cout << "职工人数为：" << num << endl; //测试代码
this->m_EmpNum = num;
this->m_EmpArray = new worker * [num];
init_Emp();

//测试代码
//for (int i = 0; i < num; i++)
//{
//	cout << "职工编号：" << this->m_EmpArray[i]->m_Id
//		<< "职工姓名：" << this->m_EmpArray[i]->m_Name
//		<< "部门编号：" << this->m_EmpArray[i]->m_DeptId << endl;
//}

```

# 10. 显示职工信息

在头文件管理类中声明显示职工信息函数

```c++
	//显示职工信息
	void show_Emp();
```

在源文件中实现：

```c++
//显示职工信息
void workerManager::show_Emp()
{
	//首先判断文件存不存在或者数据是不是为空
	if (this->m_EmpNum == 0)	//这里直接判断当前数量是可以的，因为我们在文件不存在或者文件为空的时候将数量初始化为0
	{
		cout << "当前不存在任何职工，无法显示，请先添加职工再使用本功能" << endl;
		return;
	}
	else
	{
		cout << "编号\t姓名\t职位" << endl;
		for (int i = 0; i < this->m_EmpNum; i++)
		{
			cout << this->m_EmpArray[i]->m_Id << "\t"
				<< this->m_EmpArray[i]->m_Name << "\t"
				<< this->m_EmpArray[i]->getDeptName() << endl;
		}
        //这里还有第二种方法
		//我们之前在worker类中声明了一个showInfo()的函数，并分别在三个子类中进行了重写
		//所以在这里我们可以使用多态来显示
		//for (int i = 0; i < this->m_EmpNum; i++)
		//{
		//	this->m_EmpArray[i]->showInfo();
		//}
	}
    system("pause");
	system("cls");
}

```

# 11. 删除职工

按照职工的编号进行删除职工的操作

首先在头文件中声明函数

```c++
	//删除职工
	void del_Emp();
```

在源文件中实现该函数

很多功能都需要用到根据职工是否来进行操作，比如删除职工、查找职工、修改职工

因此我们将判断职工是否存在函数封装起来，方便后续调用

在头文件中声明函数：

```c++
	//判断职工是否存在
	int IsExist(int id);
```

我们首先实现判断函数：

```c++

//判断职工是否存在
int workerManager::IsExist(int id)
{
	int index = -1;
	for (int i = 0; i < this->m_EmpNum; i++)
	{
		if (this->m_EmpArray[i]->m_Id == id)
		{
			index = i;
			break;
		}
	}
	return index;
}
```

然后我们来实现删除的函数：

```c++
//删除职工
void workerManager::del_Emp()
{
	//首先判断还有没有人
	if (this->m_EmpNum == 0)
	{
		cout << "当前不存在任何职工，无法删除，请先添加职工再使用本功能" << endl;
	}
	else
	{
		//判断职工是否存在
		cout << "请输入您想删除的职工编号：";
		int delid;
		cin >> delid;
		int temp = IsExist(delid);
		if (temp == -1)
		{
			cout << "您输入的职工编号有误！" << endl;
		}
		else
		{
			int a = 0;
			cout << "请确认您的操作，您将要删除" << delid << "号职工" << endl;
			cout << "输入1来确认操作，输入其他数返回" << endl;
			cin >> a;
			if(a == 1)
			{
				for (int i = temp; i < this->m_EmpNum - 1; i++)
				{
					this->m_EmpArray[i] = this->m_EmpArray[i + 1];
				}

				this->m_EmpNum--;
				this->save();
				cout << "删除成功！当前剩余" << this->m_EmpNum << "位职工" << endl;
			}
			else
			{
				cout << "退出删除操作" << endl;
			}
		}
	}
	system("pause");
	system("cls");
}
```

# 12. 修改职工

功能描述：能够按照职工的编号对职工信息进行修改并保存

首先声明

```c++
//修改职工
void mod_Emp();
```

然后实现：

```c++
//修改职工
void workerManager::mod_Emp()
{
	//还是一样，先进行判断有没有数据
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法修改，请先添加职工再使用本功能" << endl;
	}
	else
	{
		//然后判断有没有对应的职工编号
		cout << "请输入您想修改的职工编号：";
		int modid;
		cin >> modid;
		int temp = IsExist(modid);
		if (temp == -1)
		{
			cout << "您输入的职工编号有误！" << endl;
		}
		else
		{
			int id;
			string name;
			int empid;
			delete this->m_EmpArray[temp];

			cout << "请输入修改后的职工编号：";
			cin >> id;
			cout << endl;

			cout << "请输入修改后的职工姓名：";
			cin >> name;
			cout << endl;

			cout << "请输入修改后的职工职位编号(1.普通员工  2.经理  3.老板)：";
			cin >> modid;
			cout << endl;

			worker* worker = NULL;
			switch (modid)
			{
			case 1:
				worker = new employee(id, name, 1);
				break;
			case 2:
				worker = new manager(id, name, 2);
				break;
			case 3:
				worker = new boss(id, name, 3);
				break;
			default:
				break;
			}

			this->m_EmpArray[temp] = worker;

			this->save();
			cout << "修改成功！" << endl;
		}
		system("pause");
		system("cls");
	}
}
```

# 13. 查找职工

功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名

由于需要按照编号来查询，因此不允许出现重复编号，我们在添加职工函数中修改：
![image-20251105224457687](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20251105224457687.png)

这样就保证了我们添加的所有职工都是不同编号，然后就可以做查找职工的功能了

首先声明：

```c++
//查找职工
void find_Emp();
```

然后开始实现：

```c++
//查找职工
void workerManager::find_Emp()
{
	//一样，首先判断当前还有没有人
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法修改，请先添加职工再使用本功能" << endl;
	}
	else
	{
		//两种查找方式
		cout << "请选择您想要使用的查询方式：" << endl;
		cout << "1、按照编号查询" << endl;
		cout << "2、按照姓名查询" << endl;		//按照姓名查询有可能有多个人，因此待会得注意一下
		int usercin;
		cin >> usercin;
		if (usercin != 1 && usercin != 2)//首先做一下不是1和2的，这个简单
		{
			cout << "输入有误！" << endl;
			system("pause");
			system("cls");
			return;
		}
		else if(usercin == 1)//按照编号查询
		{
			//判断有没有对应的职工编号
			cout << "请输入您想查找的职工编号：";
			int findid;
			cin >> findid;
			int temp = IsExist(findid);
			if (temp == -1)
			{
				cout << "您输入的职工编号有误！" << endl;
			}
			else
			{
				this->m_EmpArray[temp]->showInfo();
			}
			system("pause");
			system("cls");
		}
		else if (usercin == 2)//按照姓名查询
		{
			cout << "请输入您想查找的职工姓名：";
			string findname;
			cin >> findname;
			bool found = false; //设置一个标记
			for (int i = 0; i < this->m_EmpNum; i++)
			{
				if (this->m_EmpArray[i]->m_Name == findname)
				{
					this->m_EmpArray[i]->showInfo();
					found = true;//如果打印了信息，把这个标记置为真
				}
			}
			if (found == false)//在for循环结束后，如果打印了信息，found应该为真，那么就不执行下面的语句；如果没有打印任何信息，found应该不会被影响，为假，就会执行下面的语句
			{
				cout << "未查询到" << findname << "的信息，请检查您输入的姓名是否有误！" << endl;
			}
			system("pause");
			system("cls");
			return;
		}
	}
}
```

这样的查询方式，在使用编号查找时，是精确查找，只会找到唯一的人；当使用姓名查找时，会输出所有姓名的人

# 14. 排序

功能描述：按照职工编号进行排序，排序的顺序由用户指定

首先声明

```c++
//排序职工
void sort_Emp();
```

然后开始实现：

```c++
//排序职工
void workerManager::sort_Emp()
{
	//先判断有没有
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法排序，请先添加职工再使用本功能" << endl;
	}
	else
	{
		cout << "请选择排序方式：" << endl;
		cout << "1、按照编号正序排序" << endl;
		cout << "2、按照编号逆序排序" << endl;
		int userchoice = 0;
		cin >> userchoice;

		if (userchoice != 1 && userchoice != 2)//还是一样的，先做不是1和2的
		{
			cout << "输入有误！" << endl;
			system("pause");
			system("cls");
			return;
		}
		else if (userchoice == 1)
		{
			for (int i = 0; i < this->m_EmpNum - 1; i++)
			{
				for(int j = 0;j < this->m_EmpNum-i-1; j++)
				{
					if (this->m_EmpArray[j]->m_Id > this->m_EmpArray[j + 1]->m_Id)
					{
						worker* temp;
						temp = this->m_EmpArray[j];
						this->m_EmpArray[j] = this->m_EmpArray[j + 1];
						this->m_EmpArray[j + 1] = temp;
					}
				}
			}
			cout << "排序已完成！排序后所有信息如下：" << endl;
			this->save();//排序完成后保存
			show_Emp();
		}
		else if (userchoice == 2)
		{
			for (int i = 0; i < this->m_EmpNum - 1; i++)
			{
				for (int j = 0; j < this->m_EmpNum - i - 1; j++)
				{
					if (this->m_EmpArray[j]->m_Id < this->m_EmpArray[j + 1]->m_Id)
					{
						worker* temp;
						temp = this->m_EmpArray[j];
						this->m_EmpArray[j] = this->m_EmpArray[j + 1];
						this->m_EmpArray[j + 1] = temp;
					}
				}
			}
			cout << "排序已完成！排序后所有信息如下：" << endl;
			this->save();//排序完成后保存
			show_Emp();
		}
	}

}
```

# 15. 清空文件

功能描述：将文件中记录数据清空

先声明：

```c++
//清空文件
void clean_file();
```

实现：

```c++
//清空文件
void workerManager::clean_file()
{
	//有没有
	if (this->m_fileisempty)
	{
		cout << "当前记录为空，无须再清空！" << endl;
	}
	else
	{
		//首先要给用户加一层确认
		int usersure = 0;
		cout << "您将清空所有数据，本操作不可中断和撤销，请确保您并非误操作！" << endl;
		cout << "输入10086来确认清空，输入其他返回。" << endl;
		cin >> usersure;
		if (usersure != 10086)
		{
			cout << "操作已取消!" << endl;
			system("pause");
			system("cls");
			return;
		}
		else
		{
			cout << "您将要清空所有数据，请输入管理员密码：";
			int secondsure = 0;
			cin >> secondsure;
			if (secondsure != 20040915)
			{
				cout << "密码验证错误！" << endl;
				system("pause");
				system("cls");
				return;
			}
			else
			{
				cout << "数据已清空！" << endl;
				delete[] this->m_EmpArray;
				this->m_EmpArray = NULL;
				this->m_EmpNum = 0;
				this->m_fileisempty = true;
				fstream ofs;
				ofs.open(filename, ios::trunc);// trunc 表示清空内容
				ofs.close();
				this->save();

			}
			system("pause");
			system("cls");
			return;
		}
	}
}
```

# 16. 全部代码

## 1.源文件

### 职工管理系统.cpp

```c++
#include <iostream>
#include <string>
#include <fstream>

#include "workerManager.h"
#include "worker.h"
#include "employee.h"
#include "manager.h"
#include "boss.h"

using namespace std;


int main()
{
	workerManager wm;//创建workerManager对象

	int choice = 0;//初始化用户选择
	while (1)
	{
		wm.show_Menu();//放入循环里，让每一次都显示菜单
		cout << "请输入您想使用的功能：";
		cin >> choice;//等待用户输入
		if (choice >= 0 && choice <= 7)//判断用户输入是不是在0到7之间，如果是执行选择功能语句
		{
			switch (choice)
			{
			case 0:		//退出系统
				wm.exitsystem();
				break;
			case 1:		//增加职工
				wm.AddEmp();
				break;
			case 2:		//显示职工
				wm.show_Emp();
				break;
			case 3:		//删除职工
				wm.del_Emp();
				break;
			case 4:		//修改职工
				wm.mod_Emp();
				break;
			case 5:		//查找职工
				wm.find_Emp();
				break;
			case 6:		//排序职工
				wm.sort_Emp();
				break;
			case 7:		//清空文档
				wm.clean_file();
				break;
			}
		}
		else	//如果输入不是0到7之间
		{
			cout << "输入不合法！" << endl;
			return 0;
		}
	}

	system("pause");
	return 0;
}
```

### boss.cpp

```c++
#include "boss.h"

boss::boss(int id, string name, int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}

//显示个人信息
void boss::showInfo()
{
	cout << "职工编号：" << this->m_Id
		<< "\t职工姓名：" << this->m_Name
		<< "\t岗位：" << this->getDeptName()
		<< "\t  岗位职责：管理公司所有事务" << endl;
}
//获取岗位名称
string  boss::getDeptName()
{
	return string("老板");
}

```

### employee.cpp

```c++
#include "employee.h"

//构造函数
employee::employee(int id, string name, int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}
//显示个人信息
void employee::showInfo()
{
	cout << "职工编号：" << this->m_Id
		<< "\t职工姓名：" << this->m_Name
		<< "\t岗位：" << this->getDeptName()
		<< "\t  岗位职责：完成经理交给的任务" << endl;
	
}
//获取岗位名称
string employee::getDeptName()
{
	return string("普通员工");
}
```

### manager.cpp

```c++
#include "manager.h"

manager::manager(int id,string name,int deptid)
{
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}

//显示个人信息
void manager::showInfo()
{
	cout << "职工编号：" << this->m_Id
		<< "\t职工姓名：" << this->m_Name
		<< "\t岗位：" << this->getDeptName()
		<< "\t  岗位职责：完成老板交给的任务，并下发任务给员工" << endl;
}
//获取岗位名称
string  manager::getDeptName()
{
	return string("经理");
}

```

### workerManager.cpp

```c++
#include "workerManager.h"//与头文件关联

workerManager::workerManager()
{

	//读文件
	fstream ifs;
	ifs.open(filename, ios::in);

	//文件不存在情况
	if (!ifs.is_open())
	{
		//cout << "文件不存在" << endl;//测试代码
		//初始化记录人数
		this->m_EmpNum = 0;
		//初始化数组指针
		this->m_EmpArray = NULL;
		//初始化文件是否为空
		this->m_fileisempty = true;

		ifs.close();
		return;
	}

	//文件存在但是数据为空
	char ch;
	ifs >> ch;
	if (ifs.eof())
	{
		//cout << "文件为空！" << endl;	//测试代码
		//初始化记录人数
		this->m_EmpNum = 0;
		//初始化数组指针
		this->m_EmpArray = NULL;
		//初始化文件是否为空
		this->m_fileisempty = true;

		ifs.close();
		return;
	}

	//文件存在并且数据不为空
	int num = this->get_EmpNum();
	//cout << "职工人数为：" << num << endl; //测试代码
	this->m_EmpNum = num;
	this->m_EmpArray = new worker * [num];
	init_Emp();

	//测试代码
	//for (int i = 0; i < num; i++)
	//{
	//	cout << "职工编号：" << this->m_EmpArray[i]->m_Id
	//		<< "职工姓名：" << this->m_EmpArray[i]->m_Name
	//		<< "部门编号：" << this->m_EmpArray[i]->m_DeptId << endl;
	//}
}

//展示菜单
void workerManager::show_Menu()
{
	cout << "**************************************" << endl;
	cout << "********欢迎使用职工管理系统！********" << endl;
	cout << "*********  0.退出管理程序  ***********" << endl;
	cout << "*********  1.增加职工信息  ***********" << endl;
	cout << "*********  2.显示职工信息  ***********" << endl;
	cout << "*********  3.删除离职职工  ***********" << endl;
	cout << "*********  4.修改职工信息  ***********" << endl;
	cout << "*********  5.查找职工信息  ***********" << endl;
	cout << "*********  6.按照编号排序  ***********" << endl;
	cout << "*********  7.清空所有信息  ***********" << endl;
	cout << endl;
}

//添加职工
void workerManager::AddEmp()
{
	cout << "请输入您想添加的职工数量：";

	int addnum = 0;//保存用户的输入数量
	cin >> addnum;
	if (addnum > 0)
	{
		//添加
		//计算添加新空间的大小
		int newsize = this->m_EmpNum + addnum;//新空间大小等于原来记录的人数 + 新增人数

		//开辟新空间
		worker ** newspace = new worker* [newsize];

		//如果原来有记录，应该先将原来的空间下的数据拷贝到新空间下
		if (this->m_EmpNum != 0)
		{
			for (int i = 0; i < this->m_EmpNum; i++)
			{
				newspace[i] = this->m_EmpArray[i];
			}
		}
			//批量添加数据
		for (int i = 0; i < addnum; i++)
		{
			int id;//编号
			string name;//姓名
			int dept;//部门编号

			cout << "请输入第" << i + 1 << "位职工的编号：";
			cin >> id;

			//判断有没有重复的编号
			int sameid = IsExist(id);//传入用户输入的id，返回-1就是没有相同的,那么返回值只要不是-1那么就是有相同的
			if (sameid != -1)
			{
				cout << "添加的职工与现有职工编号相同，添加失败！" << endl;
				system("pause");   
				system("cls");     
				return;
			}
			cout << endl;
			cout << "请输入第" << i + 1 << "位职工的姓名：";
			cin >> name;
			cout << endl;
			cout << "请输入该职工的部门编号(1:普通职工  2:经理  3:老板)：";
			cin >> dept;
			cout << endl;
				
			worker* worker = NULL;
			switch (dept)
			{
			case 1:
				worker = new employee(id, name, 1);
				break;
			case 2:
				worker = new manager(id, name, 2);
				break;
			case 3:
				worker = new boss(id, name, 3);
				break;
			default:
				break;
			}
				//将创建的职工指针保存到数组中
				newspace[this->m_EmpNum + i] = worker;
			
		}
		//释放原有空间
		delete[] this->m_EmpArray;

		//更改新空间指向
		this->m_EmpArray = newspace;

		//更新职工人数
		this->m_EmpNum = newsize;

		cout << "添加成功，成功添加" << addnum << "位职工" << endl;


		//更新职工文件是否存在
		this->m_fileisempty = false;

		//成功添加后应该做一个保存到文件的操作
		this->save();
	}
	else
	{
		cout << "输入数据有误！" << endl;

	}
	system("pause");
	system("cls");

}

//保存文件
void workerManager::save()
{
	fstream ofs;
	ofs.open(filename, ios::out);
	for (int i = 0; i < this->m_EmpNum; i++)
	{
		ofs << this->m_EmpArray[i]->m_Id << "\t"
			<< this->m_EmpArray[i]->m_Name << "\t"
			<< this->m_EmpArray[i]->m_DeptId << endl;
	}


	ofs.close();
}

//获取文件中人数
int workerManager::get_EmpNum()
{
	fstream ifs;
	ifs.open(filename, ios::in);

	int id;
	string name;
	int did;

	int num = 0;
	while (ifs >> id && ifs >> name && ifs >> did)
	{
		num++;
	}

	ifs.close();

	return num;
}

//初始化职工
void workerManager::init_Emp()
{
	ifstream ifs;
	ifs.open(filename, ios::in);
	
	int id;
	string name;
	int did;

	int temp = 0;
	while (ifs >> id && ifs >> name && ifs >> did)
	{
		worker* worker = NULL;

		//根据不同的部门id来创建不同的对象
		if (did == 1)
		{
			worker = new employee(id, name, 1);
		}
		else if (did == 2)
		{
			worker = new manager(id, name, 2);
		}
		else
		{
			worker = new boss(id, name, 3);
		} 
		this->m_EmpArray[temp] = worker;
		temp++;
	}



	ifs.close();
}

//显示职工信息
void workerManager::show_Emp()
{
	//首先判断文件存不存在或者数据是不是为空
	if (this->m_EmpNum == 0)	//这里直接判断当前数量是可以的，因为我们在文件不存在或者文件为空的时候将数量初始化为0
	{
		cout << "当前不存在任何职工，无法显示，请先添加职工再使用本功能" << endl;
	}
	else
	{
		//cout << "编号\t姓名\t职位" << endl;
		//for (int i = 0; i < this->m_EmpNum; i++)
		//{
		//	cout << this->m_EmpArray[i]->m_Id << "\t"
		//		<< this->m_EmpArray[i]->m_Name << "\t"
		//		<< this->m_EmpArray[i]->getDeptName() << endl;
		//}
		//这里还有第二种方法
		//我们之前在worker类中声明了一个showInfo()的函数，并分别在三个子类中进行了重写
		//所以在这里我们可以使用多态来显示
		for (int i = 0; i < this->m_EmpNum; i++)
		{
			this->m_EmpArray[i]->showInfo();
		}
	}
	system("pause");
	system("cls");
}

//删除职工
void workerManager::del_Emp()
{
	//首先判断还有没有人
	if (this->m_EmpNum == 0)
	{
		cout << "当前不存在任何职工，无法删除，请先添加职工再使用本功能" << endl;
	}
	else
	{
		//判断职工是否存在
		cout << "请输入您想删除的职工编号：";
		int delid;
		cin >> delid;
		int temp = IsExist(delid);
		if (temp == -1)
		{
			cout << "您输入的职工编号有误！" << endl;
		}
		else
		{
			int a = 0;
			cout << "请确认您的操作，您将要删除" << delid << "号职工" << endl;
			cout << "输入1来确认操作，输入其他数返回" << endl;
			cin >> a;
			if(a == 1)
			{
				for (int i = temp; i < this->m_EmpNum - 1; i++)
				{
					this->m_EmpArray[i] = this->m_EmpArray[i + 1];
				}

				this->m_EmpNum--;
				this->save();
				cout << "删除成功！当前剩余" << this->m_EmpNum << "位职工" << endl;
			}
			else
			{
				cout << "退出删除操作" << endl;
			}
		}
	}
	system("pause");
	system("cls");
}

//判断职工是否存在
int workerManager::IsExist(int id)
{
	int index = -1;
	for (int i = 0; i < this->m_EmpNum; i++)
	{
		if (this->m_EmpArray[i]->m_Id == id)
		{
			index = i;
			break;
		}
	}
	return index;
}


//修改职工
void workerManager::mod_Emp()
{
	//还是一样，先进行判断有没有数据
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法修改，请先添加职工再使用本功能" << endl;
		system("pause");
		system("cls");
	}
	else
	{
		//然后判断有没有对应的职工编号
		cout << "请输入您想修改的职工编号：";
		int modid;
		cin >> modid;
		int temp = IsExist(modid);
		if (temp == -1)
		{
			cout << "您输入的职工编号有误！" << endl;
		}
		else
		{
			int id;
			string name;
			int empid;
			delete this->m_EmpArray[temp];

			cout << "请输入修改后的职工编号：";
			cin >> id;
			cout << endl;

			cout << "请输入修改后的职工姓名：";
			cin >> name;
			cout << endl;

			cout << "请输入修改后的职工职位编号(1.普通员工  2.经理  3.老板)：";
			cin >> modid;
			cout << endl;

			worker* worker = NULL;
			switch (modid)
			{
			case 1:
				worker = new employee(id, name, 1);
				break;
			case 2:
				worker = new manager(id, name, 2);
				break;
			case 3:
				worker = new boss(id, name, 3);
				break;
			default:
				break;
			}

			this->m_EmpArray[temp] = worker;

			this->save();
			cout << "修改成功！" << endl;
		}
		system("pause");
		system("cls");
	}
}


//查找职工
void workerManager::find_Emp()
{
	//一样，首先判断当前还有没有人
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法查找，请先添加职工再使用本功能" << endl;
		system("pause");
		system("cls");
	}
	else
	{
		//两种查找方式
		cout << "请选择您想要使用的查询方式：" << endl;
		cout << "1、按照编号查询" << endl;
		cout << "2、按照姓名查询" << endl;		//按照姓名查询有可能有多个人，因此待会得注意一下
		int usercin;
		cin >> usercin;
		if (usercin != 1 && usercin != 2)//首先做一下不是1和2的，这个简单
		{
			cout << "输入有误！" << endl;
			system("pause");
			system("cls");
			return;
		}
		else if(usercin == 1)//按照编号查询
		{
			//判断有没有对应的职工编号
			cout << "请输入您想查找的职工编号：";
			int findid;
			cin >> findid;
			int temp = IsExist(findid);
			if (temp == -1)
			{
				cout << "您输入的职工编号有误！" << endl;
			}
			else
			{
				this->m_EmpArray[temp]->showInfo();
			}
			system("pause");
			system("cls");
		}
		else if (usercin == 2)//按照姓名查询
		{
			cout << "请输入您想查找的职工姓名：";
			string findname;
			cin >> findname;
			bool found = false; //设置一个标记
			for (int i = 0; i < this->m_EmpNum; i++)
			{
				if (this->m_EmpArray[i]->m_Name == findname)
				{
					this->m_EmpArray[i]->showInfo();
					found = true;//如果打印了信息，把这个标记置为真
				}
			}
			if (found == false)//在for循环结束后，如果打印了信息，found应该为真，那么就不执行下面的语句；如果没有打印任何信息，found应该不会被影响，为假，就会执行下面的语句
			{
				cout << "未查询到" << findname << "的信息，请检查您输入的姓名是否有误！" << endl;
			}
			system("pause");
			system("cls");
			return;
		}
	}
}

//排序职工
void workerManager::sort_Emp()
{
	//先判断有没有
	if (this->m_fileisempty)
	{
		cout << "当前不存在任何职工，无法排序，请先添加职工再使用本功能" << endl;
		system("pause");
		system("cls");
	}
	else
	{
		cout << "请选择排序方式：" << endl;
		cout << "1、按照编号正序排序" << endl;
		cout << "2、按照编号逆序排序" << endl;
		int userchoice = 0;
		cin >> userchoice;

		if (userchoice != 1 && userchoice != 2)//还是一样的，先做不是1和2的
		{
			cout << "输入有误！" << endl;
			system("pause");
			system("cls");
			return;
		}
		else if (userchoice == 1)
		{
			for (int i = 0; i < this->m_EmpNum - 1; i++)
			{
				for(int j = 0;j < this->m_EmpNum-i-1; j++)
				{
					if (this->m_EmpArray[j]->m_Id > this->m_EmpArray[j + 1]->m_Id)
					{
						worker* temp;
						temp = this->m_EmpArray[j];
						this->m_EmpArray[j] = this->m_EmpArray[j + 1];
						this->m_EmpArray[j + 1] = temp;
					}
				}
			}
			cout << "排序已完成！排序后所有信息如下：" << endl;
			this->save();//排序完成后保存
			show_Emp();
		}
		else if (userchoice == 2)
		{
			for (int i = 0; i < this->m_EmpNum - 1; i++)
			{
				for (int j = 0; j < this->m_EmpNum - i - 1; j++)
				{
					if (this->m_EmpArray[j]->m_Id < this->m_EmpArray[j + 1]->m_Id)
					{
						worker* temp;
						temp = this->m_EmpArray[j];
						this->m_EmpArray[j] = this->m_EmpArray[j + 1];
						this->m_EmpArray[j + 1] = temp;
					}
				}
			}
			cout << "排序已完成！排序后所有信息如下：" << endl;
			this->save();//排序完成后保存
			show_Emp();
		}
	}

}

//清空文件
void workerManager::clean_file()
{
	//有没有
	if (this->m_fileisempty)
	{
		cout << "当前记录为空，无须再清空！" << endl;
	}
	else
	{
		//首先要给用户加一层确认
		int usersure = 0;
		cout << "您将清空所有数据，本操作不可中断和撤销，请确保您并非误操作！" << endl;
		cout << "输入10086来确认清空，输入其他返回。" << endl;
		cin >> usersure;
		if (usersure != 10086)
		{
			cout << "操作已取消!" << endl;
			system("pause");
			system("cls");
			return;
		}
		else
		{
			cout << "您将要清空所有数据，请输入管理员密码：";
			int secondsure = 0;
			cin >> secondsure;
			if (secondsure != 20040915)
			{
				cout << "密码验证错误！" << endl;
				system("pause");
				system("cls");
				return;
			}
			else
			{
				cout << "数据已清空！" << endl;
				delete[] this->m_EmpArray;
				this->m_EmpArray = NULL;
				this->m_EmpNum = 0;
				this->m_fileisempty = true;
				fstream ofs;
				ofs.open(filename, ios::trunc);// trunc 表示清空内容
				ofs.close();
				this->save();

			}
			system("pause");
			system("cls");
			return;
		}
	}
}

//退出程序
void workerManager::exitsystem()
{
	cout << "系统即将退出，感谢您的使用，期待与您的下次见面！" << endl;
	system("pause");//请按任意键继续
	exit(0);//退出程序函数
}

workerManager::~workerManager()
{
	if (this->m_EmpArray != NULL)
	{
		delete[] this->m_EmpArray;
		this->m_EmpArray = NULL;
	}

}
```

## 2.头文件

### boss.h

```c++
#pragma once
#include <iostream>


#include "worker.h"
using namespace std;

class boss :public worker
{
public:
	boss(int id, string name, int deptid);

	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();
};
```

### employee.h

```c++
#pragma once
#include <iostream>

#include "worker.h"
using namespace std;

class employee : public worker
{
public:
	//构造函数
	employee(int id,string name,int deptid);
	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();

};
```

### manager.h

```c++
#pragma once
#include <iostream>


#include "worker.h"
using namespace std;

class manager :public worker
{
public:
	manager(int id, string name, int deptid);

	//显示个人信息
	virtual void showInfo();
	//获取岗位名称
	virtual string getDeptName();
};
```

### worker.h

抽象类，不需要实现，因此没有源文件

```c++
#pragma once
#include <iostream>
#include <string>

using namespace std;

//创建职工抽象类
class worker
{
public:
	
	//显示个人信息
	virtual void showInfo() = 0;
	//获取岗位名称
	virtual string getDeptName() = 0;

	int m_Id;//职工编号
	string m_Name;//职工姓名
	int m_DeptId;//职工所在部门编号

};
```

### workerManager.h

```c++
#pragma once	//防止头文件重复包含
#include <iostream>//包含输入输出流头文件
#include <fstream> // 包含文件交互头文件

#include "worker.h"
#include "employee.h"
#include "manager.h"
#include "boss.h"

//这里是绝对路径，也可以自己设置路径
#define filename "C:/Users/dell/AppData/Roaming/Employee Management/empFile.txt"

using namespace std;//使用标准命名空间

//创建管理类
class workerManager
{
public:
	workerManager();//构造函数的声明

	//展示菜单
	void show_Menu();

	//记录职工人数
	int m_EmpNum;

	//职工数组指针
	worker** m_EmpArray;

	//添加职工函数
	void AddEmp();

	//保存文件
	void save();

	//标志文件是否为空
	bool m_fileisempty;

	//获取文件人数
	int get_EmpNum();

	//初始化职工
	void init_Emp();

	//显示职工信息
	void show_Emp();

	//删除职工
	void del_Emp();

	//修改职工
	void mod_Emp();

	//查找职工
	void find_Emp();

	//排序职工
	void sort_Emp();

	//判断职工是否存在
	int IsExist(int id);

	//清空文件
	void clean_file();
	
	//退出程序
	void exitsystem();

	~workerManager();//析构函数的声明

};
```

